---
---

<div class="hex-mesh-container">
  <canvas id="hexMesh" class="hex-mesh-canvas"></canvas>
</div>

<script is:inline>
  class HexagonalMesh {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.nodes = [];
      // Initialize mouse off-screen to prevent initial bounce
      this.mouse = { x: -10000, y: -10000 };
      this.animationId = null;
      this.rotationX = 0;
      this.rotationY = 0;
      this.rotationSpeed = 0.0008;
      
      this.setupCanvas();
      this.createSphere();
      this.bindEvents();
      this.animate();
    }
    
    setupCanvas() {
      const resize = () => {
        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
        this.createSphere();
      };
      resize();
      window.addEventListener('resize', resize);
    }
    
    createSphere() {
      this.nodes = [];
      const radius = Math.min(this.canvas.offsetWidth, this.canvas.offsetHeight) * 0.25;
      
      // Create nodes on a sphere surface
      const segments = 24;
      const rings = 18;
      
      for (let ring = 0; ring < rings; ring++) {
        const phi = (ring / (rings - 1)) * Math.PI;
        const ringRadius = Math.sin(phi) * radius;
        const y = Math.cos(phi) * radius;
        
        const nodesInRing = Math.max(1, Math.floor(segments * Math.sin(phi)));
        
        for (let i = 0; i < nodesInRing; i++) {
          const theta = (i / nodesInRing) * Math.PI * 2;
          const x = Math.cos(theta) * ringRadius;
          const z = Math.sin(theta) * ringRadius;
          
          this.nodes.push({
            x3d: x,
            y3d: y,
            z3d: z,
            baseX3d: x,
            baseY3d: y,
            baseZ3d: z,
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            size: 2.5 + Math.random() * 1.5,
            angle: Math.random() * Math.PI * 2,
            rotationSpeed: 0.001 + Math.random() * 0.002,
            connections: []
          });
        }
      }
      
      // Calculate connections between nearby nodes
      const maxConnectionDistance = radius * 0.35;
      this.nodes.forEach((node, i) => {
        node.connections = [];
        this.nodes.forEach((other, j) => {
          if (i !== j) {
            const dx = node.baseX3d - other.baseX3d;
            const dy = node.baseY3d - other.baseY3d;
            const dz = node.baseZ3d - other.baseZ3d;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            if (distance < maxConnectionDistance) {
              node.connections.push(j);
            }
          }
        });
      });
    }
    
    bindEvents() {
      // Track mouse over entire hero section (parent container)
      const heroSection = this.canvas.closest('.hero');
      const container = heroSection || this.canvas.parentElement;
      
      const updateMouse = (e) => {
        const rect = this.canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        this.mouse.x = (e.clientX - rect.left) * dpr;
        this.mouse.y = (e.clientY - rect.top) * dpr;
      };
      
      // Track mouse over container
      if (container) {
        container.addEventListener('mousemove', updateMouse);
        container.addEventListener('mouseleave', () => {
          this.mouse.x = -10000;
          this.mouse.y = -10000;
        });
      }
      
      // Also track on canvas as fallback
      this.canvas.addEventListener('mousemove', updateMouse);
      this.canvas.addEventListener('mouseleave', () => {
        this.mouse.x = -10000;
        this.mouse.y = -10000;
      });
    }
    
    rotate3D(x, y, z, rotX, rotY) {
      let x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
      let z1 = x * Math.sin(rotY) + z * Math.cos(rotY);
      
      let y1 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
      let z2 = y * Math.sin(rotX) + z1 * Math.cos(rotX);
      
      return { x: x1, y: y1, z: z2 };
    }
    
    project3D(x, y, z, centerX, centerY) {
      const dpr = window.devicePixelRatio || 1;
      const perspective = 800;
      const scale = perspective / (perspective + z);
      return {
        x2d: centerX + x * scale,
        y2d: centerY + y * scale,
        scale: scale,
        z: z
      };
    }
    
    update() {
      // Continuous rotation at all times (like botronics)
      this.rotationX += 0.0008;
      this.rotationY += 0.0012;
      
      const dpr = window.devicePixelRatio || 1;
      const centerX = this.canvas.offsetWidth / 2;
      const centerY = this.canvas.offsetHeight / 2;
      
      this.nodes.forEach((node) => {
        // Rotate 3D position
        const rotated = this.rotate3D(node.baseX3d, node.baseY3d, node.baseZ3d, this.rotationX, this.rotationY);
        
        // Project to 2D
        const projected = this.project3D(rotated.x, rotated.y, rotated.z, centerX, centerY);
        
        let targetX = projected.x2d * dpr;
        let targetY = projected.y2d * dpr;
        
        // Mouse interaction - strong and visible like botronics
        const dx = this.mouse.x - targetX;
        const dy = this.mouse.y - targetY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate distance from sphere center for proximity-based interaction
        const centerXScaled = centerX * dpr;
        const centerYScaled = centerY * dpr;
        const dxFromCenter = targetX - centerXScaled;
        const dyFromCenter = targetY - centerYScaled;
        const distanceFromCenter = Math.sqrt(dxFromCenter * dxFromCenter + dyFromCenter * dyFromCenter);
        const maxSphereRadius = Math.min(this.canvas.offsetWidth, this.canvas.offsetHeight) * 0.35 * dpr;
        const centerProximity = 1 - Math.min(distanceFromCenter / maxSphereRadius, 1);
        
        // Strong interaction - larger influence radius and stronger repulsion
        const baseInfluenceRadius = 450 * dpr;
        const influenceRadius = baseInfluenceRadius * (0.7 + centerProximity * 0.3);
        const baseRepelStrength = 250 * dpr;
        const repelStrength = baseRepelStrength * (0.8 + centerProximity * 0.2);
        
        if (distance < influenceRadius && distance > 0) {
          // Strong force calculation - very visible push-away
          const force = Math.pow(1 - distance / influenceRadius, 1.8);
          const angle = Math.atan2(dy, dx);
          const repelDistance = force * repelStrength;
          
          // Push nodes away from cursor - make space for cursor
          targetX -= Math.cos(angle) * repelDistance;
          targetY -= Math.sin(angle) * repelDistance;
        }
        
        // Very responsive physics - immediate reaction like botronics
        const spring = 0.25;
        const damping = 0.92;
        
        node.vx += (targetX - node.x) * spring;
        node.vy += (targetY - node.y) * spring;
        
        node.vx *= damping;
        node.vy *= damping;
        
        node.x += node.vx;
        node.y += node.vy;
        
        // Store depth for rendering
        node.depth = projected.z;
        node.scale = projected.scale;
        
        // Rotate hexagon
        node.angle += node.rotationSpeed;
      });
    }
    
    draw() {
      const dpr = window.devicePixelRatio || 1;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      // Sort nodes by depth (back to front)
      const sortedNodes = [...this.nodes].sort((a, b) => (b.depth || 0) - (a.depth || 0));
      
      // Draw connections first
      this.ctx.lineWidth = 1 * dpr;
      
      sortedNodes.forEach(node => {
        node.connections.forEach(connIndex => {
          const connected = this.nodes[connIndex];
          const distance = Math.sqrt(
            Math.pow(node.x - connected.x, 2) + 
            Math.pow(node.y - connected.y, 2)
          );
          
          const maxLineDistance = 200 * dpr;
          if (distance < maxLineDistance) {
            const opacity = Math.max(0, 0.2 * (1 - distance / maxLineDistance));
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            
            this.ctx.beginPath();
            this.ctx.moveTo(node.x, node.y);
            this.ctx.lineTo(connected.x, connected.y);
            this.ctx.stroke();
          }
        });
      });
      
      // Draw hexagonal nodes
      sortedNodes.forEach((node) => {
        const depth = (node.depth + 400) / 800;
        const size = node.size * node.scale * (0.6 + depth * 0.4) * dpr;
        const opacity = 0.4 + depth * 0.4;
        
        this.ctx.save();
        this.ctx.translate(node.x, node.y);
        this.ctx.rotate(node.angle);
        
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = 'high';
        this.ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 1.5})`;
        this.ctx.lineWidth = Math.max(1, 1.2 * dpr);
        this.ctx.lineJoin = 'miter';
        this.ctx.lineCap = 'square';
        
        this.drawHexagon(0, 0, size);
        
        this.ctx.restore();
      });
    }
    
    drawHexagon(x, y, size) {
      const round = (n) => Math.round(n * 2) / 2;
      
      this.ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i;
        const hx = round(x + size * Math.cos(angle));
        const hy = round(y + size * Math.sin(angle));
        if (i === 0) {
          this.ctx.moveTo(hx, hy);
        } else {
          this.ctx.lineTo(hx, hy);
        }
      }
      this.ctx.closePath();
      this.ctx.fill();
      this.ctx.stroke();
    }
    
    animate() {
      this.update();
      this.draw();
      this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    destroy() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }
  
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('hexMesh');
    if (canvas) {
      new HexagonalMesh(canvas);
    }
  });
</script>

<style>
  .hex-mesh-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
    overflow: hidden;
  }
  
  .hex-mesh-canvas {
    width: 100%;
    height: 100%;
    display: block;
    pointer-events: auto;
  }
</style>
