---
---

<div class="hex-mesh-container">
  <canvas id="hexMesh" class="hex-mesh-canvas"></canvas>
</div>

<script is:inline>
  class HexagonalMesh {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.nodes = [];
      this.mouse = { x: 0, y: 0 };
      this.animationId = null;
      this.time = 0;
      this.rotationX = 0;
      this.rotationY = 0;
      this.rotationSpeed = 0.002;
      
      this.setupCanvas();
      this.createSphere();
      this.bindEvents();
      this.animate();
    }
    
    setupCanvas() {
      const resize = () => {
        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
        this.createSphere();
      };
      resize();
      window.addEventListener('resize', resize);
    }
    
    createSphere() {
      this.nodes = [];
      const radius = Math.min(this.canvas.width, this.canvas.height) * 0.4;
      const centerX = this.canvas.width / 2;
      const centerY = this.canvas.height / 2;
      
      // Create nodes on a sphere surface
      const segments = 20;
      const rings = 15;
      
      for (let ring = 0; ring < rings; ring++) {
        const phi = (ring / (rings - 1)) * Math.PI; // Vertical angle
        const ringRadius = Math.sin(phi) * radius;
        const y = Math.cos(phi) * radius;
        
        const nodesInRing = Math.floor(segments * Math.sin(phi)) || 1;
        
        for (let i = 0; i < nodesInRing; i++) {
          const theta = (i / nodesInRing) * Math.PI * 2; // Horizontal angle
          const x = Math.cos(theta) * ringRadius;
          const z = Math.sin(theta) * ringRadius;
          
          // Store 3D position
          this.nodes.push({
            x3d: x,
            y3d: y,
            z3d: z,
            baseX3d: x,
            baseY3d: y,
            baseZ3d: z,
            x: 0,
            y: 0,
            vx: 0,
            vy: 0,
            size: 2 + Math.random() * 2,
            angle: Math.random() * Math.PI * 2,
            rotationSpeed: 0.002 + Math.random() * 0.003,
            connections: []
          });
        }
      }
      
      // Calculate connections between nearby nodes
      const maxConnectionDistance = radius * 0.3;
      this.nodes.forEach((node, i) => {
        node.connections = [];
        this.nodes.forEach((other, j) => {
          if (i !== j) {
            const dx = node.baseX3d - other.baseX3d;
            const dy = node.baseY3d - other.baseY3d;
            const dz = node.baseZ3d - other.baseZ3d;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            if (distance < maxConnectionDistance) {
              node.connections.push(j);
            }
          }
        });
      });
    }
    
    bindEvents() {
      this.canvas.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        this.mouse.x = (e.clientX - rect.left) * dpr;
        this.mouse.y = (e.clientY - rect.top) * dpr;
      });
      
      this.canvas.addEventListener('mouseleave', () => {
        this.mouse.x = -10000;
        this.mouse.y = -10000;
      });
    }
    
    getCanvasSize() {
      return {
        width: this.canvas.offsetWidth,
        height: this.canvas.offsetHeight
      };
    }
    
    rotate3D(x, y, z, rotX, rotY) {
      // Rotate around Y axis
      let x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
      let z1 = x * Math.sin(rotY) + z * Math.cos(rotY);
      
      // Rotate around X axis
      let y1 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
      let z2 = y * Math.sin(rotX) + z1 * Math.cos(rotX);
      
      return { x: x1, y: y1, z: z2 };
    }
    
    project3D(x, y, z, centerX, centerY) {
      const dpr = window.devicePixelRatio || 1;
      const perspective = 800;
      const scale = perspective / (perspective + z);
      return {
        x2d: centerX + x * scale,
        y2d: centerY + y * scale,
        scale: scale,
        z: z
      };
    }
    
    update() {
      this.time += this.rotationSpeed;
      this.rotationX += 0.001;
      this.rotationY += 0.0015;
      
      const dpr = window.devicePixelRatio || 1;
      const centerX = this.canvas.offsetWidth / 2;
      const centerY = this.canvas.offsetHeight / 2;
      const maxDistance = Math.min(this.canvas.offsetWidth, this.canvas.offsetHeight) * 0.5;
      
      this.nodes.forEach((node, index) => {
        // Rotate 3D position
        const rotated = this.rotate3D(node.baseX3d, node.baseY3d, node.baseZ3d, this.rotationX, this.rotationY);
        
        // Project to 2D
        const projected = this.project3D(rotated.x, rotated.y, rotated.z, centerX, centerY);
        
        let targetX = projected.x2d * dpr;
        let targetY = projected.y2d * dpr;
        
        // Mouse interaction - stronger in center, weaker at edges
        const dx = this.mouse.x - targetX;
        const dy = this.mouse.y - targetY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate distance from center
        const centerXScaled = centerX * dpr;
        const centerYScaled = centerY * dpr;
        const dxFromCenter = targetX - centerXScaled;
        const dyFromCenter = targetY - centerYScaled;
        const distanceFromCenter = Math.sqrt(dxFromCenter * dxFromCenter + dyFromCenter * dyFromCenter);
        const maxDistanceScaled = maxDistance * dpr;
        const centerProximity = 1 - Math.min(distanceFromCenter / maxDistanceScaled, 1);
        
        // Adjust influence based on center proximity - stronger in center
        const baseInfluence = 400 * dpr;
        const mouseInfluence = baseInfluence * (0.6 + centerProximity * 0.4); // 240-400px range
        const baseRepelStrength = 100 * dpr;
        const mouseRepelStrength = baseRepelStrength * (0.7 + centerProximity * 0.3); // 70-100 range
        
        if (distance < mouseInfluence && distance > 0) {
          const force = Math.pow((mouseInfluence - distance) / mouseInfluence, 2);
          const angle = Math.atan2(dy, dx);
          const repelDistance = force * mouseRepelStrength;
          
          targetX -= Math.cos(angle) * repelDistance;
          targetY -= Math.sin(angle) * repelDistance;
        }
        
        // Smooth interpolation
        node.vx += (targetX - node.x) * 0.12;
        node.vy += (targetY - node.y) * 0.12;
        
        // Apply velocity with less damping for more responsiveness
        node.vx *= 0.75;
        node.vy *= 0.75;
        
        node.x += node.vx;
        node.y += node.vy;
        
        // Store depth for rendering
        node.depth = projected.z;
        node.scale = projected.scale;
        
        // Rotate hexagon
        node.angle += node.rotationSpeed;
      });
    }
    
    draw() {
      const dpr = window.devicePixelRatio || 1;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      // Sort nodes by depth (back to front)
      const sortedNodes = [...this.nodes].sort((a, b) => (b.depth || 0) - (a.depth || 0));
      
      // Draw connections first (behind nodes)
      this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
      this.ctx.lineWidth = 0.5 * dpr;
      
      sortedNodes.forEach(node => {
        node.connections.forEach(connIndex => {
          const connected = this.nodes[connIndex];
          const distance = Math.sqrt(
            Math.pow(node.x - connected.x, 2) + 
            Math.pow(node.y - connected.y, 2)
          );
          
          if (distance < 150 * dpr) {
            const opacity = Math.max(0, 0.08 * (1 - distance / (150 * dpr)));
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            
            this.ctx.beginPath();
            this.ctx.moveTo(node.x, node.y);
            this.ctx.lineTo(connected.x, connected.y);
            this.ctx.stroke();
          }
        });
      });
      
      // Draw hexagonal nodes with depth effect - crisp rendering
      sortedNodes.forEach((node) => {
        const depth = (node.depth + 400) / 800; // Normalize depth
        const size = node.size * node.scale * (0.5 + depth * 0.5) * dpr;
        const opacity = 0.15 + depth * 0.5;
        
        this.ctx.save();
        this.ctx.translate(node.x, node.y);
        this.ctx.rotate(node.angle);
        
        // Enable crisp rendering
        this.ctx.imageSmoothingEnabled = true;
        this.ctx.imageSmoothingQuality = 'high';
        this.ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 1.8})`;
        this.ctx.lineWidth = Math.max(1, 1.5 * dpr);
        this.ctx.lineJoin = 'miter';
        this.ctx.lineCap = 'square';
        
        this.drawHexagon(0, 0, size);
        
        this.ctx.restore();
      });
    }
    
    drawHexagon(x, y, size) {
      // Round coordinates for crisp rendering
      const round = (n) => Math.round(n * 2) / 2;
      
      this.ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i;
        const hx = round(x + size * Math.cos(angle));
        const hy = round(y + size * Math.sin(angle));
        if (i === 0) {
          this.ctx.moveTo(hx, hy);
        } else {
          this.ctx.lineTo(hx, hy);
        }
      }
      this.ctx.closePath();
      this.ctx.fill();
      this.ctx.stroke();
    }
    
    animate() {
      this.update();
      this.draw();
      this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    destroy() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }
  
  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('hexMesh');
    if (canvas) {
      new HexagonalMesh(canvas);
    }
  });
</script>

<style>
  .hex-mesh-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
    overflow: hidden;
  }
  
  .hex-mesh-canvas {
    width: 100%;
    height: 100%;
    display: block;
    pointer-events: auto;
  }
</style>
