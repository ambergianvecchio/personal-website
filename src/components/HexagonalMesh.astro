---
---

<div class="hex-mesh-container">
  <canvas id="hexMesh" class="hex-mesh-canvas"></canvas>
</div>

<script is:inline>
  class HexagonalMesh {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.nodes = [];
      this.mouse = { x: 0, y: 0 };
      this.animationId = null;
      this.time = 0;
      this.rotationSpeed = 0.0005;
      
      this.setupCanvas();
      this.createNodes();
      this.bindEvents();
      this.animate();
    }
    
    setupCanvas() {
      const resize = () => {
        this.canvas.width = this.canvas.offsetWidth;
        this.canvas.height = this.canvas.offsetHeight;
        this.createNodes(); // Recreate nodes on resize
      };
      resize();
      window.addEventListener('resize', resize);
    }
    
    createNodes() {
      this.nodes = [];
      const cols = 12;
      const rows = 10;
      const spacingX = this.canvas.width / (cols + 1);
      const spacingY = this.canvas.height / (rows + 1);
      
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const x = spacingX * (col + 1) + (row % 2 === 0 ? 0 : spacingX / 2);
          const y = spacingY * (row + 1);
          
          // Add some randomness for organic feel
          const offsetX = (Math.random() - 0.5) * 20;
          const offsetY = (Math.random() - 0.5) * 20;
          
          this.nodes.push({
            x: x + offsetX,
            y: y + offsetY,
            baseX: x,
            baseY: y,
            size: 3 + Math.random() * 2,
            vx: 0,
            vy: 0,
            angle: Math.random() * Math.PI * 2,
            rotationSpeed: 0.001 + Math.random() * 0.002
          });
        }
      }
    }
    
    bindEvents() {
      this.canvas.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.mouse.x = e.clientX - rect.left;
        this.mouse.y = e.clientY - rect.top;
      });
      
      this.canvas.addEventListener('mouseleave', () => {
        this.mouse.x = -10000;
        this.mouse.y = -10000;
      });
    }
    
    update() {
      this.time += this.rotationSpeed;
      const centerX = this.canvas.width / 2;
      const centerY = this.canvas.height / 2;
      const mouseInfluence = 200;
      const mouseRepelStrength = 30;
      
      this.nodes.forEach((node, index) => {
        // Slow orbital rotation around center
        const dxFromCenter = node.baseX - centerX;
        const dyFromCenter = node.baseY - centerY;
        const distanceFromCenter = Math.sqrt(dxFromCenter * dxFromCenter + dyFromCenter * dyFromCenter);
        
        const baseAngle = Math.atan2(dyFromCenter, dxFromCenter);
        const rotationRadius = distanceFromCenter * 0.2;
        const rotationAngle = baseAngle + this.time + (index * 0.05);
        
        const targetX = centerX + Math.cos(rotationAngle) * distanceFromCenter;
        const targetY = centerY + Math.sin(rotationAngle) * distanceFromCenter;
        
        // Add subtle floating motion
        const floatX = Math.sin(this.time * 2 + index) * 3;
        const floatY = Math.cos(this.time * 1.5 + index) * 3;
        
        let finalTargetX = targetX + floatX;
        let finalTargetY = targetY + floatY;
        
        // Mouse interaction - more fluid repulsion
        const dx = this.mouse.x - finalTargetX;
        const dy = this.mouse.y - finalTargetY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < mouseInfluence && distance > 0) {
          const force = (mouseInfluence - distance) / mouseInfluence;
          const angle = Math.atan2(dy, dx);
          const repelDistance = force * mouseRepelStrength;
          
          finalTargetX -= Math.cos(angle) * repelDistance;
          finalTargetY -= Math.sin(angle) * repelDistance;
        }
        
        // Smooth interpolation for fluid movement
        node.vx += (finalTargetX - node.x) * 0.05;
        node.vy += (finalTargetY - node.y) * 0.05;
        
        // Apply velocity with damping
        node.vx *= 0.85;
        node.vy *= 0.85;
        
        node.x += node.vx;
        node.y += node.vy;
        
        // Rotate hexagon
        node.angle += node.rotationSpeed;
      });
    }
    
    draw() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      // Draw hexagonal nodes with depth effect
      this.nodes.forEach((node, index) => {
        // Calculate distance from center for depth effect
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;
        const dx = node.x - centerX;
        const dy = node.y - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);
        const depth = 1 - (distance / maxDistance) * 0.5;
        
        // Size varies with depth
        const size = node.size * depth;
        
        // Opacity varies with depth and position
        const opacity = 0.2 + depth * 0.4;
        
        this.ctx.save();
        this.ctx.translate(node.x, node.y);
        this.ctx.rotate(node.angle);
        
        // Draw hexagon with gradient-like effect
        this.ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${opacity * 1.5})`;
        this.ctx.lineWidth = 1;
        
        this.drawHexagon(0, 0, size);
        
        this.ctx.restore();
      });
    }
    
    drawHexagon(x, y, size) {
      this.ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i;
        const hx = x + size * Math.cos(angle);
        const hy = y + size * Math.sin(angle);
        if (i === 0) {
          this.ctx.moveTo(hx, hy);
        } else {
          this.ctx.lineTo(hx, hy);
        }
      }
      this.ctx.closePath();
      this.ctx.fill();
      this.ctx.stroke();
    }
    
    animate() {
      this.update();
      this.draw();
      this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    destroy() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }
  
  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('hexMesh');
    if (canvas) {
      new HexagonalMesh(canvas);
    }
  });
</script>

<style>
  .hex-mesh-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
    overflow: hidden;
  }
  
  .hex-mesh-canvas {
    width: 100%;
    height: 100%;
    display: block;
    pointer-events: auto;
  }
</style>
