---
---

<div class="hex-mesh-container">
  <canvas id="hexMesh" class="hex-mesh-canvas"></canvas>
</div>

<script is:inline>
  class HexagonalMesh {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.nodes = [];
      this.mouse = { x: 0, y: 0 };
      this.animationId = null;
      this.time = 0;
      this.rotationSpeed = 0.0003; // Slow rotation speed
      
      this.setupCanvas();
      this.createNodes();
      this.bindEvents();
      this.animate();
    }
    
    setupCanvas() {
      const resize = () => {
        this.canvas.width = this.canvas.offsetWidth;
        this.canvas.height = this.canvas.offsetHeight;
      };
      resize();
      window.addEventListener('resize', resize);
    }
    
    createNodes() {
      const cols = 8;
      const rows = 6;
      const spacingX = this.canvas.width / (cols + 1);
      const spacingY = this.canvas.height / (rows + 1);
      
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const x = spacingX * (col + 1) + (row % 2 === 0 ? 0 : spacingX / 2);
          const y = spacingY * (row + 1);
          
          this.nodes.push({
            x,
            y,
            baseX: x,
            baseY: y,
            size: 4,
            connections: []
          });
        }
      }
      
      // Calculate connections (connect nearby nodes)
      const maxDistance = Math.min(spacingX, spacingY) * 1.5;
      this.nodes.forEach((node, i) => {
        node.connections = [];
        this.nodes.forEach((other, j) => {
          if (i !== j) {
            const dx = node.x - other.x;
            const dy = node.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < maxDistance) {
              node.connections.push(j);
            }
          }
        });
      });
    }
    
    bindEvents() {
      this.canvas.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.mouse.x = e.clientX - rect.left;
        this.mouse.y = e.clientY - rect.top;
      });
      
      this.canvas.addEventListener('mouseleave', () => {
        this.mouse.x = -1000;
        this.mouse.y = -1000;
      });
    }
    
    update() {
      this.time += this.rotationSpeed;
      const mouseInfluence = 150;
      const centerX = this.canvas.width / 2;
      const centerY = this.canvas.height / 2;
      
      this.nodes.forEach((node, index) => {
        // Calculate distance from center
        const dxFromCenter = node.baseX - centerX;
        const dyFromCenter = node.baseY - centerY;
        const distanceFromCenter = Math.sqrt(dxFromCenter * dxFromCenter + dyFromCenter * dyFromCenter);
        
        // Slow circular rotation around center
        const baseAngle = Math.atan2(dyFromCenter, dxFromCenter);
        const rotationRadius = distanceFromCenter * 0.15; // Subtle rotation
        const rotationAngle = baseAngle + this.time + (index * 0.1); // Each node rotates slightly offset
        
        const rotatedX = centerX + Math.cos(rotationAngle) * distanceFromCenter;
        const rotatedY = centerY + Math.sin(rotationAngle) * distanceFromCenter;
        
        // Mouse interaction
        const dx = this.mouse.x - rotatedX;
        const dy = this.mouse.y - rotatedY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < mouseInfluence) {
          const force = (mouseInfluence - distance) / mouseInfluence;
          const angle = Math.atan2(dy, dx);
          const pushDistance = force * 20;
          
          node.x = rotatedX + Math.cos(angle) * pushDistance;
          node.y = rotatedY + Math.sin(angle) * pushDistance;
        } else {
          // Use rotated position as base
          node.x = rotatedX;
          node.y = rotatedY;
        }
      });
    }
    
    draw() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      // Draw connections
      this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      this.ctx.lineWidth = 1;
      
      this.nodes.forEach(node => {
        node.connections.forEach(connIndex => {
          const connected = this.nodes[connIndex];
          this.ctx.beginPath();
          this.ctx.moveTo(node.x, node.y);
          this.ctx.lineTo(connected.x, connected.y);
          this.ctx.stroke();
        });
      });
      
      // Draw hexagonal nodes
      this.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
      this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      this.ctx.lineWidth = 1.5;
      
      this.nodes.forEach(node => {
        this.drawHexagon(node.x, node.y, node.size);
      });
    }
    
    drawHexagon(x, y, size) {
      this.ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (Math.PI / 3) * i;
        const hx = x + size * Math.cos(angle);
        const hy = y + size * Math.sin(angle);
        if (i === 0) {
          this.ctx.moveTo(hx, hy);
        } else {
          this.ctx.lineTo(hx, hy);
        }
      }
      this.ctx.closePath();
      this.ctx.fill();
      this.ctx.stroke();
    }
    
    animate() {
      this.update();
      this.draw();
      this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    destroy() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }
  
  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('hexMesh');
    if (canvas) {
      new HexagonalMesh(canvas);
    }
  });
</script>

<style>
  .hex-mesh-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
    overflow: hidden;
  }
  
  .hex-mesh-canvas {
    width: 100%;
    height: 100%;
    display: block;
    pointer-events: auto;
  }
</style>

